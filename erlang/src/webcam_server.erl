-module(webcam_server).
-export([run_server/1,webcam_loop/1,transmit_loop/6]).
-on_load(init/0).

% Packet type definitions.
-define(PKT_GET,16#81).
-define(PKT_DAT,16#82).
-define(PKT_RES,16#83).
-define(PKT_ACK,16#84).
-define(SIZEOF_GET_FIXED_FIELDS,12).
-define(SIZEOF_DAT_FIXED_FIELDS,18).

-define(ASSERT,true).
-include_lib("stdlib/include/assert.hrl").
-include("image.hrl").

% Load the NIF for computation of CRC16.
init() ->
    SoName = filename:join(case code:priv_dir(?MODULE) of
                               {error, bad_name} ->
                                   %% this is here for testing purposes
                                   filename:join(
                                     [filename:dirname(
                                        code:which(?MODULE)),"..","priv"]);
                               Dir ->
                                   Dir
                           end, "crc16_nif"),
    ok = erlang:load_nif(SoName, 0).

% This is the dummy method called if the NIF is unloaded for whatever reason.
crc16( _Bin ) ->
	exit( nif_library_not_loaded ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DAT         1
% FLAG        1
% Packet Size 2
% Request Id  4
% Object Size 4
% Fragment Id 4
% Fragment    *
% CRC16       2
%mk_data_packet( Flag, Rid, ObjSize, Fragnum, Fragment ) 
%	-> << ?PKT_DAT, Flag, 3:16/big >>.

% - Frags is an (ordered!) list of binaries containing contiguous
%   stretches of a file (a PNG image).
% - Rid is the Request ID, a value randomly generated by the client
%   to distinguish one request from the next.
%
% Rid and Frags are const for the lifetime of the process executing 
% transmit_loop. Every UDP packet received by transmit_loop should
% contain the same RID.
%
% - Selector specifies which elements of the Frags list to transmit.

transmit_loop( Rid, Frags, Selector, XmtSock, CliAddr, CliPort ) ->

	io:format( "entered transmit_loop( ~p ~p )~n", [ CliAddr, CliPort ] ),

	% Create packets from all the fragments
	Size = lists:sum( lists:map( fun(El) -> size(El) end, Frags )),
	lists:foreach( fun( N ) -> 
			Flag = (if N =:= length(Frags) -> 1; true -> 0 end),
			Frag = lists:nth(N,Frags),
			% remember client uses 0-based FID, we use 1-based!
			Body = << ?PKT_DAT, Flag, (size(Frag)):16, Rid:32, Size:32, (N-1):32, Frag/binary >>,
			CRC  = crc16( Body ),
			gen_udp:send( XmtSock, CliAddr, CliPort, << Body/bitstring, CRC:16 >> )
			end,
			Selector ),

	receive
		{udp, Sock2, Addr2, Port2, Pack } ->
			ComputedCrc = crc16( binary_part( Pack, 0, size(Pack)-2 ) ),
			<<Cmd, Flag, PSize:16/unsigned-big, RID:32/unsigned-big,
				Payload:PSize/binary, _SentCRC:16/big>> = Pack,
			% Verify RID is same.
			io:fwrite( "crc=~4.16.0B ~p ~p ~p ~n",
					[ ComputedCrc, Sock2, Addr2, Port2 ] ),
			io:fwrite( "~2.16.0B ~2.16.0B ~4.16.0B ~8.16.0B~n",
					[ Cmd, Flag, PSize, RID ] ),
			case Cmd of 
			?PKT_RES ->
				Newlist = lists:map( fun(N) ->
					% remember client uses 0-based FID, we use 1-based!
					1 + binary:decode_unsigned(binary:part(Payload,N,4)) end,
					lists:seq( 0, size(Payload)-4,4) ),
				transmit_loop( Rid, Frags, Newlist, XmtSock, CliAddr, CliPort );
			?PKT_ACK ->
				io:fwrite( "~2.16.0B ~2.16.0B ~4.16.0B ~8.16.0B. Exiting transmit_loop~n",
						[ Cmd, Flag, PSize, RID ] )
			end
	after
		10000 -> 
			io:format("Abandoning RID ~8.16.0B.~n", [ Rid ]),
			ok
	end.

% server_loop handles the initial GET request by spawning a process.
% ALL handling of the GET request occurs in the child process, except
% possibly some initial validation of the request (shouldn't spawn a child
% unless the request is valid).
webcam_loop( WaiterArgs ) ->
	io:format( "entered webcam_loop( ~p )~n", [WaiterArgs] ),
	receive
		{udp,Sock,Addr,Port,Pack} ->
			% 1. Validate the packet contents
			% 2. acquire the image (list of binary fragments), and
			% 3. start another process on a random port to handle ALL else.
			ComputedCrc = crc16( binary_part( Pack, 0, size(Pack)-2 ) ),
			<<Cmd/big,
				Flag/big,
				PSize:16/unsigned-big,
				RID:32/unsigned-big,
				Mtu:16/unsigned-big,
				ReceivedCRC:16/unsigned-big>> = Pack,
			io:fwrite( "crc=~4.16.0B ~p ~p ~p ~n",
					[ ComputedCrc, Sock, Addr, Port ] ),
			io:fwrite( "~2.16.0B ~2.16.0B ~4.16.0B ~8.16.0B ~8.16.0B ~4.16.0B ~n",
					[ Cmd, Flag, PSize, RID, Mtu, ReceivedCRC ] ),

			% Acquire an image, fragment it...
			Fragments = snapshot:get_fragmented_image( Mtu-?SIZEOF_DAT_FIXED_FIELDS ),
			%ObjSize = lists:sum( lists:map( fun(El) -> size(El) end, Fragments )),
			% ...and hand it off to another child process to transmit.
			{ok, Xmtsock} = gen_udp:open( 0, [binary,inet,{active,true}]),
			% Don't link to this child; we don't care when it exits.
			Xmtproc = spawn( ?MODULE, transmit_loop,
					[ RID, Fragments, lists:seq(1, length(Fragments)), Xmtsock, Addr, Port ]),
			gen_udp:controlling_process( Xmtsock, Xmtproc ),

			% This process has now washed its hands of the request and can
			% serve others.
			webcam_loop( WaiterArgs );

		_ ->
			io:format("Unexpected message in webcam_loop.~n", []),
			webcam_loop( WaiterArgs )
	end.

run_server( Port ) -> 
	?assert( erlang:is_integer(Port) ),
	io:fwrite( "\"~p\" ~n", [ Port ] ),
	{ok, Socket} = gen_udp:open( Port, [binary,inet,{active,true}]),
	Pid = spawn_link( ?MODULE, webcam_loop, [Port] ),
	gen_udp:controlling_process( Socket, Pid ),
%%	register('mushroom',Pid),
	{ok,Pid,some_info}.

